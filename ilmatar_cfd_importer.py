bl_info = {
    "name": "Ilmatar CFD importer",
    "description": "Add-on to import simulation data generated by Ilmatar CFD into Blender.",
    "author": "Jakob Schoser",
    "version": (1, 0),
    "blender": (4, 4, 0),
    "location": "View3D > Sidebar > Ilmatar CFD importer",
    "warning": "",
    "doc_url": "",
    "tracker_url": "",
    "category": "Object",
}

import bpy
import numpy as np
import openvdb as vdb
import os


# Helper functions
def get_density(data):
    return data[..., 0]


def get_velocity(data):
    return data[..., 1:-1] / get_density(data)[..., np.newaxis]


def get_specific_internal_energy(data):
    density = get_density(data)
    total_energy = data[..., -1]
    velocity = get_velocity(data)
    kinetic_energy = 0.5 * density * np.einsum("ijkl,ijkl->ijk", velocity, velocity)
    return (total_energy - kinetic_energy) / density


# Base operator to handle Ilmatar CFD output data
class ILMATAR_CFD_OT_base(bpy.types.Operator):
    def execute(self, context):
        return {"FINISHED"}

    def convert_to_vdb(self, data, lo, dx, dir, name, context, suffix=""):
        # Create VDB grids
        var_suffix = ""
        grids = []
        transform = vdb.createLinearTransform(voxelSize=dx)
        transform.postTranslate(lo)
        if context.scene.ilmatar_cfd_density:
            grids.append(self.create_density_grid(data, transform))
            var_suffix += "_den"
        if context.scene.ilmatar_cfd_velocity:
            grids.append(self.create_velocity_grid(data, transform))
            var_suffix += "_vel"
        if context.scene.ilmatar_cfd_specific_internal_energy:
            grids.append(self.create_specific_internal_energy_grid(data, transform))
            var_suffix += "_ene"
        if not grids:
            self.report({"ERROR"}, "Select at least one physical quantity for import")
            return ""

        # Save VDB file
        base = os.path.splitext(name)[0]
        vdb_path = os.path.join(dir, base + var_suffix + suffix + ".vdb")
        vdb.write(vdb_path, grids=grids)

        return vdb_path
    
    def load_header(self, header_path):
        info = {}

        try:
            with open(header_path, "r") as f:
                info["step"] = int(f.readline())
                info["time"] = float(f.readline())
                info["lo"] = np.asarray([float(i) for i in f.readline().split()])
                info["hi"] = np.asarray([float(i) for i in f.readline().split()])
                info["res"] = np.asarray([int(i) for i in f.readline().split()])
                info["NVARS"] = int(f.readline())
                info["data_filename"] = f.readline().rstrip()
        except FileNotFoundError:
            self.report({"ERROR"}, "Header file not found: " + header_path)
            return {}
        except ValueError:
            self.report({"ERROR"}, "Invalid header file: " + header_path)
            return {}
        
        GRIDDIM = len(info["res"])
        if len(info["lo"]) != GRIDDIM or len(info["hi"]) != GRIDDIM:
            self.report({"ERROR"}, "Dimension mismatch in grid parameters")
            return {}

        if GRIDDIM != 3:
            self.report({"ERROR"}, "Wrong grid dimension: " + str(GRIDDIM) + " (must be 3)")
            return {}
        
        if info["NVARS"] != 5:
            self.report({"ERROR"}, "Wrong number of variables: " + str(info["NVARS"]) + " (must be 5)")
            return {}
        
        dx = np.asarray([(info["hi"][d] - info["lo"][d])/info["res"][d] for d in range(GRIDDIM)])
        if not np.allclose(dx, dx[0]):
            self.report({"ERROR"}, "Non-square cells")
            return {}
        info["dx"] = dx[0]
        
        return info
    
    def load_data(self, header_path, info):
        dir = os.path.dirname(header_path)
        data_path = os.path.join(dir, info["data_filename"])

        try:
            REAL = np.float64  # Assumes that files were written with double precision
            count = np.prod(info["res"]) * info["NVARS"]
            with open(data_path, "rb") as f:
                data = np.fromfile(f, dtype=REAL, count=count).reshape((*info["res"], info["NVARS"]))
        except FileNotFoundError:
            self.report({"ERROR"}, "Data file not found: " + data_path)
            return None
        except ValueError:
            self.report({"ERROR"}, "Invalid data file: " + data_path)
            return None
        
        return data
    
    def create_density_grid(self, data, transform):
        density = get_density(data)
        density_grid = vdb.FloatGrid()
        density_grid.name = "density"
        density_grid.copyFromArray(np.ascontiguousarray(density))
        density_grid.transform = transform
        return density_grid
    
    def create_velocity_grid(self, data, transform):
        velocity = get_velocity(data)
        velocity_grid = vdb.Vec3DGrid()
        velocity_grid.name = "velocity"
        velocity_grid.copyFromArray(np.ascontiguousarray(velocity))
        velocity_grid.transform = transform
        return velocity_grid
    
    def create_specific_internal_energy_grid(self, data, transform):
        specific_internal_energy = get_specific_internal_energy(data)
        specific_internal_energy_grid = vdb.FloatGrid()
        specific_internal_energy_grid.name = "specific internal energy"
        specific_internal_energy_grid.copyFromArray(np.ascontiguousarray(specific_internal_energy))
        specific_internal_energy_grid.transform = transform
        return specific_internal_energy_grid


# Operator to import a single header file
class ILMATAR_CFD_OT_import_header(ILMATAR_CFD_OT_base):
    bl_idname = "ilmatar_cfd.import_header"
    bl_label = "Import header"

    def execute(self, context):
        header_path = bpy.path.abspath(context.scene.ilmatar_cfd_header_file)
        
        # Load data
        info = self.load_header(header_path)
        if not info:
            return {"CANCELLED"}
        data = self.load_data(header_path, info)
        if data is None:
            return {"CANCELLED"}
        
        # Convert data to VDB file
        dir, filename = os.path.split(header_path)
        vdb_path = self.convert_to_vdb(data, info["lo"], info["dx"], dir, filename, context)
        if not vdb_path:
            return {"CANCELLED"}

        # Import VDB file
        bpy.ops.object.volume_import(filepath=vdb_path, align="WORLD")
        
        return {"FINISHED"}


# Operator to import a series of header files
class ILMATAR_CFD_OT_import_series(ILMATAR_CFD_OT_base):
    bl_idname = "ilmatar_cfd.import_series"
    bl_label = "Import series"

    def execute(self, context):
        # Read selected series file
        series_path = bpy.path.abspath(context.scene.ilmatar_cfd_series_file)
        header_paths = self.load_series(series_path)
        if not header_paths:
            return {"CANCELLED"}
        
        # Load info from the first header file
        base_info = self.load_header(header_paths[0])
        if not base_info:
                return {"CANCELLED"}
        
        # Read all info and ensure that it is consistent 
        # with the first header file
        infos = [base_info]
        for header_path in header_paths[1:]:
            info = self.load_header(header_path)
            if not info:
                return {"CANCELLED"}
            
            if self.geom_matching(base_info, info):
                infos.append(info)
            else:
                self.report({"ERROR"}, "Domain geometry in " + header_path + " does not match " + header_paths[0])
                return {"CANCELLED"}

        # Load data and convert it to VDB files
        vdb_paths = []
        for i, (header_path, info) in enumerate(zip(header_paths, infos)):
            data = self.load_data(header_path, info)
            if data is None:
                return {"CANCELLED"}
            
            dir, filename = os.path.split(series_path)
            vdb_path = self.convert_to_vdb(data, info["lo"], info["dx"], dir, filename, context, suffix="_" + str(i))
            if vdb_path:
                vdb_paths.append(vdb_path)
            else:
                return {"CANCELLED"}
        
        # Import first VDB file
        bpy.ops.object.volume_import(filepath=vdb_paths[0], directory=os.path.dirname(vdb_paths[0]), files=[{"name": os.path.split(vdb_path)[1]} for vdb_path in vdb_paths], align="WORLD")

        return {"FINISHED"}

    def load_series(self, series_path):
        dir = os.path.dirname(series_path)
        try:
            header_paths = []
            with open(series_path, "r") as f:
                header_paths = [os.path.join(dir, header_path.rstrip()) for header_path in f.readlines()]
        except FileNotFoundError:
            self.report({"ERROR"}, "Series file not found: " + series_path)
        if not header_paths:
            self.report({"ERROR"}, "Empty series file: " + series_path)
        return header_paths
    
    def geom_matching(self, info1, info2):
        return np.allclose(info1["lo"], info2["lo"]) and np.allclose(info1["hi"], info2["hi"]) and np.all(info1["res"] == info2["res"])


# Panel to select files and import them
class ILMATAR_CFD_PT_import(bpy.types.Panel):
    bl_idname = "ILMATAR_CFD_PT_import"
    bl_space_type = "VIEW_3D"
    bl_region_type = "UI"
    bl_category = "Ilmatar CFD importer"
    bl_label = "Import data"

    def draw(self, context):
        col = self.layout.column(align=True)
        col.prop(context.scene, "ilmatar_cfd_header_file")
        col.operator(ILMATAR_CFD_OT_import_header.bl_idname)
        col.prop(context.scene, "ilmatar_cfd_series_file")
        col.operator(ILMATAR_CFD_OT_import_series.bl_idname)
        col.prop(context.scene, "ilmatar_cfd_density")
        col.prop(context.scene, "ilmatar_cfd_velocity")
        col.prop(context.scene, "ilmatar_cfd_specific_internal_energy")


blender_classes = [
    ILMATAR_CFD_OT_import_header, 
    ILMATAR_CFD_OT_import_series,
    ILMATAR_CFD_PT_import,
]


def register():
    bpy.types.Scene.ilmatar_cfd_header_file = bpy.props.StringProperty(name="Header file", default="", subtype="FILE_PATH")
    bpy.types.Scene.ilmatar_cfd_series_file = bpy.props.StringProperty(name="Series file", default="", subtype="FILE_PATH")
    bpy.types.Scene.ilmatar_cfd_density = bpy.props.BoolProperty(name="density", default=True)
    bpy.types.Scene.ilmatar_cfd_velocity = bpy.props.BoolProperty(name="velocity", default=True)
    bpy.types.Scene.ilmatar_cfd_specific_internal_energy = bpy.props.BoolProperty(name="specific internal energy", default=True)
    for blender_class in blender_classes:
        bpy.utils.register_class(blender_class)


def unregister():
    del bpy.types.Scene.ilmatar_cfd_header_file
    del bpy.types.Scene.ilmatar_cfd_series_file
    del bpy.types.Scene.ilmatar_cfd_density
    del bpy.types.Scene.ilmatar_cfd_velocity
    del bpy.types.Scene.ilmatar_cfd_specific_internal_energy
    for blender_class in blender_classes:
        bpy.utils.unregister_class(blender_class)
