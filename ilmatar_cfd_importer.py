bl_info = {
    "name": "Ilmatar CFD importer",
    "description": "Add-on to import simulation data generated by Ilmatar CFD into Blender.",
    "author": "Jakob Schoser",
    "version": (1, 0),
    "blender": (4, 40, 0),
    "location": "View3D > Sidebar > Ilmatar CFD importer",
    "warning": "",
    "doc_url": "",
    "tracker_url": "",
    "category": "Object",
}

import bpy
import numpy as np
import openvdb as vdb
import os


# Helper functions
def read_header_file(header_path):
    with open(header_path, "r") as f:
        _ = int(f.readline())  # Step
        _ = float(f.readline())  # Time
        lo = np.asarray([float(i) for i in f.readline().split()])
        hi = np.asarray([float(i) for i in f.readline().split()])
        res = np.asarray([int(i) for i in f.readline().split()])
        NVARS = int(f.readline())
        data_filename = f.readline().rstrip()
    return lo, hi, res, NVARS, data_filename


def read_data_file(data_path, res, NVARS):
    REAL = np.float64  # Assumes that files were written with double precision
    count = np.prod(res) * NVARS
    with open(data_path, "rb") as f:
        data = np.fromfile(f, dtype=REAL, count=count).reshape((*res, NVARS))
    return data


def get_density(data):
    return data[..., 0]


def get_velocity(data):
    return data[..., 1:-1] / get_density(data)[..., np.newaxis]


def get_specific_internal_energy(data):
    density = get_density(data)
    total_energy = data[..., -1]
    velocity = get_velocity(data)
    kinetic_energy = 0.5 * density * np.einsum("ijkl,ijkl->ijk", velocity, velocity)
    return (total_energy - kinetic_energy) / density


# Operator to import volume data
class ILMATAR_CFD_OT_volume_import(bpy.types.Operator):
    bl_idname = "ilmatar_cfd.volume_import"
    bl_label = "Import volume data"

    def execute(self, context):
        header_path = bpy.path.abspath(context.scene.ilmatar_cfd_header_file)
        
        # Load data and check correctness
        success, info = self.load_header(header_path)
        if not success:
            return {"CANCELLED"}
        data = self.load_data(header_path, info)
        if data is None:
            return {"CANCELLED"}

        # Create VDB grids
        suffix = ""
        grids = []
        transform = vdb.createLinearTransform(voxelSize=info["dx"])
        if context.scene.ilmatar_cfd_density:
            grids.append(self.create_density_grid(data, transform))
            suffix += "_den"
        if context.scene.ilmatar_cfd_velocity:
            grids.append(self.create_velocity_grid(data, transform))
            suffix += "_vel"
        if context.scene.ilmatar_cfd_specific_internal_energy:
            grids.append(self.create_specific_internal_energy_grid(data, transform))
            suffix += "_ene"
        if not grids:
            self.report({"ERROR"}, "Select at least one physical quantity for import")
            return {"CANCELLED"}

        # Save VDB file
        vdb_path = os.path.splitext(header_path)[0] + suffix + ".vdb"
        vdb.write(vdb_path, grids=grids)

        # Import VDB file
        bpy.ops.object.volume_import(filepath=vdb_path, align="WORLD", location=info["lo"])
        
        return {"FINISHED"}
    
    def load_header(self, header_path):
        info = {}

        try:
            info["lo"], info["hi"], info["res"], info["NVARS"], info["data_filename"] = read_header_file(header_path)
        except FileNotFoundError:
            self.report({"ERROR"}, "Header file not found: " + header_path)
            return False, info
        except ValueError:
            self.report({"ERROR"}, "Invalid header file: " + header_path)
            return False, info
        
        GRIDDIM = len(info["res"])
        if len(info["lo"]) != GRIDDIM or len(info["hi"]) != GRIDDIM:
            self.report({"ERROR"}, "Dimension mismatch in grid parameters")
            return False, info

        if GRIDDIM != 3:
            self.report({"ERROR"}, "Wrong grid dimension: " + str(GRIDDIM) + " (must be 3)")
            return False, info
        
        if info["NVARS"] != 5:
            self.report({"ERROR"}, "Wrong number of variables: " + str(info["NVARS"]) + " (must be 5)")
            return False, info
        
        dx = np.asarray([(info["hi"][d] - info["lo"][d])/info["res"][d] for d in range(GRIDDIM)])
        if not np.allclose(dx, dx[0]):
            self.report({"ERROR"}, "Non-square cells")
            return False, info
        info["dx"] = dx[0]
        
        return True, info
    
    def load_data(self, header_path, info):
        dir = os.path.dirname(header_path)
        data_path = dir + "/" + info["data_filename"]

        try:
            data = read_data_file(data_path, info["res"], info["NVARS"])
        except FileNotFoundError:
            self.report({"ERROR"}, "Data file not found: " + data_path)
            return None
        except ValueError:
            self.report({"ERROR"}, "Invalid data file: " + data_path)
            return None
        
        return data
    
    def create_density_grid(self, data, transform):
        density = get_density(data)
        density_grid = vdb.FloatGrid()
        density_grid.name = "density"
        density_grid.copyFromArray(np.ascontiguousarray(density))
        density_grid.transform = transform
        return density_grid
    
    def create_velocity_grid(self, data, transform):
        velocity = get_velocity(data)
        velocity_grid = vdb.Vec3DGrid()
        velocity_grid.name = "velocity"
        velocity_grid.copyFromArray(np.ascontiguousarray(velocity))
        velocity_grid.transform = transform
        return velocity_grid
    
    def create_specific_internal_energy_grid(self, data, transform):
        specific_internal_energy = get_specific_internal_energy(data)
        specific_internal_energy_grid = vdb.FloatGrid()
        specific_internal_energy_grid.name = "specific internal energy"
        specific_internal_energy_grid.copyFromArray(np.ascontiguousarray(specific_internal_energy))
        specific_internal_energy_grid.transform = transform
        return specific_internal_energy_grid


# Panel to select files and import them
class ILMATAR_CFD_PT_import(bpy.types.Panel):
    bl_idname = "ILMATAR_CFD_PT_import"
    bl_space_type = "VIEW_3D"
    bl_region_type = "UI"
    bl_category = "Ilmatar CFD importer"
    bl_label = "Import data"

    def draw(self, context):
        col = self.layout.column(align=True)
        col.prop(context.scene, "ilmatar_cfd_header_file")  # File selector for header file
        col.prop(context.scene, "ilmatar_cfd_density")  # Checkboxes to select quantities to import
        col.prop(context.scene, "ilmatar_cfd_velocity")
        col.prop(context.scene, "ilmatar_cfd_specific_internal_energy")
        col.operator("ILMATAR_CFD_OT_volume_import")  # Button to import volume data


blender_classes = [
    ILMATAR_CFD_OT_volume_import, 
    ILMATAR_CFD_PT_import,
]


def register():
    bpy.types.Scene.ilmatar_cfd_header_file = bpy.props.StringProperty(name="Header file", default="", subtype="FILE_PATH")
    bpy.types.Scene.ilmatar_cfd_density = bpy.props.BoolProperty(name="density", default=True)
    bpy.types.Scene.ilmatar_cfd_velocity = bpy.props.BoolProperty(name="velocity", default=True)
    bpy.types.Scene.ilmatar_cfd_specific_internal_energy = bpy.props.BoolProperty(name="specific internal energy", default=True)
    for blender_class in blender_classes:
        bpy.utils.register_class(blender_class)


def unregister():
    del bpy.types.Scene.ilmatar_cfd_header_file
    del bpy.types.Scene.ilmatar_cfd_density
    del bpy.types.Scene.ilmatar_cfd_velocity
    del bpy.types.Scene.ilmatar_cfd_specific_internal_energy
    for blender_class in blender_classes:
        bpy.utils.unregister_class(blender_class)
